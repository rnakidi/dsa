Here’s a DSA patterns cheatsheet that will help you solve 90-95% questions that will come your way. 

For Graph questions: 
↳ Apply DFS/BFS to traverse the graph. 
↳ Use adjacency lists for efficient representation. 
↳ Focus on detecting cycles/shortest paths depending on the problem.

For Sliding Window problems: 
↳ Adjust the window size dynamically based on constraints. 
↳ Use two pointers to track the current window. 
↳ Track sums or counts within the window to optimize results.

For Linked Lists: 
↳ Use Two Pointers to detect cycles & find the middle node. 
↳ Reverse the list in-place by pointer manipulation. 

For Maximum/Minimum Subarrays: 
↳ Use Dynamic Programming to track the optimal subarray. 
↳ Maintain a running sum and compare with current maxi/mini.
↳ Divide the problem into subproblems to simplify calculations.

For In-Place operations: 
↳ Swap corresponding values to reorder the array. 
↳ Modify the array without using extra space by storing values cleverly. 
↳ Carefully manage index positions during swapping to avoid overwriting.

For Top/Least K elements: 
↳ Use Heaps to keep track of the top/least K elements efficiently. 
↳ QuickSelect can help when sorting isn’t necessary. 
↳ Maintain a limited window of values for optimal memory usage.

For Permutations/Subsets: 
↳ Apply Backtracking to explore all possible combinations. 
↳ Prune paths that won’t lead to valid solutions early. 
↳ Track the current state and revert changes after each recursive call.

For Common Strings problems: 
↳ Use a Map/Trie to store and search for prefixes or entire strings. 
↳ Count frequencies to detect patterns or duplicates. 

For Recursion-Banned problems: 
↳ Use Stack to simulate recursive calls iteratively. 
↳ Track the state manually to mimic the recursive behavior. 
↳ Push and pop values carefully to ensure you’re following the intended logic.

For Sorted Arrays: 
↳ Use Binary Search to quickly narrow down the target range. 
↳ Use sorted properties to optimize space/time complexity.
↳ Use Two Pointers for sums or pairs. 

For Tree problems: 
↳ Traverse using DFS for deep exploration or BFS for level-wise traversal. 
↳ Keep track of visited nodes to avoid infinite loops. 
↳ Handle edge cases like unbalanced trees or missing nodes.

Else: 
↳ Use Maps/Sets for O(1) lookups and efficient space management. 
↳ Sorting can simplify problems to O(nlogn) time. 

--
P.S: If you’re currently preparing for DSA, HLD, and LLD.
Check out my one-stop resource guide on Topmate: 
→ https://lnkd.in/eYHSjbys ( 380+ students are already using it)
(Running on 25% discount for the first 25 people, I am celebrating hitting 100k)

This guide will help you with:
- DSA, HLD, and LLD for interviews
- good resources that I used personally
- lots of problems and case studies for DSA and system design

![image](https://github.com/user-attachments/assets/44ba8558-f4bb-4827-91df-8d6cf8991ff6)

Source/Credit: https://www.linkedin.com/posts/karan-saxena-466b07190_cracking-leetcode-problems-fast-during-coding-activity-7288178345035415552-Ii7e?utm_source=share&utm_medium=member_desktop
